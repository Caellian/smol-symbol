//! # Compile Symbol ðŸ’ 
//!
//! [![Crates.io](https://img.shields.io/crates/v/compile-symbol)](https://crates.io/crates/compile-symbol)
//! [![docs.rs](https://img.shields.io/docsrs/compile-symbol?label=docs)](https://docs.rs/compile-symbol/latest/compile-symbol/)
//! [![Build Status](https://img.shields.io/github/actions/workflow/status/sam0x17/compile-symbol/ci.yaml)](https://github.com/sam0x17/compile-symbol/actions/workflows/ci.yaml?query=branch%3Amain)
//! [![MIT License](https://img.shields.io/github/license/sam0x17/compile-symbol)](https://github.com/sam0x17/compile-symbol/blob/main/LICENSE)
//!
//! This crate provides the ability to create globally unique (based on input value),
//! human-readable [`Symbol`]s at compile-time as well as at run-time, that are meant to be
//! reminiscent of the `Symbol` type in the Crystal programming language.
//!
//! Where this crate differs is the alphabet and length of our [`Symbol`] is a bit more
//! restrictive, allowing us to encode the entire text of each [`Symbol`] as a [`u128`]
//! internally. The only caveat is we are limited to 25 characters of length and an alphabet
//! consisting of lowercase a-z as well as `_`.
//!
//! The [`Symbol`] type can be created at compile-time using the convenient [`s!`] macro, and
//! can also be created using the [`From<Into<String>>`] impl at runtime, though this is not as
//! efficient as using the [`s!`] macro.
//!
//! The [`Symbol`] type can also be turned into a [`String`] via a convenient [`Into<String>`].
//!
//! ### Example
#![doc = docify::embed_run!("tests/tests.rs", symbol_type_example)]
//!
//! See the docs for [`Symbol`] and [`s!`] for more detailed information.

#![no_std]

#[cfg(all(doc, feature = "generate-readme"))]
docify::compile_markdown!("README.docify.md", "README.md");

extern crate alloc;

use alloc::{string::String, vec::Vec};
pub use compile_symbol_macros::*;
use core::fmt::{Debug, Display, Formatter, Result};

/// Used to store the alphabet used in [`Symbol`]s. Note that the first item `'-'` is a no-op
/// and is present for encoding reasons. It cannot be used directly.
pub const ALPHABET: [char; 28] = [
    '-', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',
    's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '_',
];
const ALPHABET_LEN: u128 = ALPHABET.len() as u128;

/// A compact representation for a (maximum of) 25-character identifier consisting of only
/// lowercase a-z as well as `_`. Internally this data is converted to a [`u128`], allowing for
/// trivial comparison operations between symbols.
///
/// [`Symbol`]s can be created _at compile time_ using the powerful [`s!`] macro. This is the
/// preferred way of creating symbols as it incurs zero overhead at runtime.
///
/// [`Symbol`]s can also be created at runtime, albeit slower than using the [`s!`] macro, via
/// a convenient [`From<AsRef<str>>`] impl on [`Symbol`].
///
/// The [`Symbol`] struct itself impls many useful traits, including [`Copy`], [`Clone`],
/// [`Eq`], [`Ord`], [`Hash`], [`Display`], [`Debug`], [`Send`], and [`Sync`], allowing for a
/// variety of scenarios and use-cases.
///
/// ### Example
#[doc = docify::embed_run!("tests/tests.rs", test_basics)]
#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
#[repr(transparent)]
pub struct Symbol {
    data: u128,
}

impl Symbol {
    /// Used internally by the [`s!`] macro to create a [`Symbol`] from a raw [`u128`]
    /// generated by the macro.
    #[inline]
    pub const fn from_raw(data: u128) -> Self {
        Symbol { data }
    }

    /// Converts this [`Symbol`] into a human-readable [`String`] representation. This is only
    /// possible because the [`u128`] used as a backing for [`Symbol`] encodes all 5 bits of
    /// information for each of the maximum of 25 characters in the [`Symbol`].
    pub fn to_string(&self) -> String {
        self.into()
    }
}

pub struct SymbolParsingError;

impl Debug for SymbolParsingError {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result {
        f.write_str(
            "To be a valid `Symbol`, the provided string must be at least one character long, \
            at most 25 characters long, and consist only of lowercase a-z characters or `_`. \
            No other characters are permitted, nor is whitespace of any kind.",
        )
    }
}

impl TryFrom<&str> for Symbol {
    type Error = SymbolParsingError;

    /// Attempts to interpret the provided string as a valid [`Symbol`]. The usual parsing
    /// rules for [`Symbol`]s apply, namely:
    /// - At least one character
    /// - At most 25 characters
    /// - only lowercase a-z and `_` allowed
    /// - no whitespace
    ///
    /// If any of these requirements are violated, a generic [`SymbolParsingError`] is returned
    /// and parsing will abort.
    fn try_from(value: &str) -> core::result::Result<Self, Self::Error> {
        if value.is_empty() || value.len() > 25 {
            return Err(SymbolParsingError {});
        }
        let mut data: u128 = 0;
        for c in value.chars() {
            let val = match c {
                '-' => return Err(SymbolParsingError {}),
                'a' => 1,
                'b' => 2,
                'c' => 3,
                'd' => 4,
                'e' => 5,
                'f' => 6,
                'g' => 7,
                'h' => 8,
                'i' => 9,
                'j' => 10,
                'k' => 11,
                'l' => 12,
                'm' => 13,
                'n' => 14,
                'o' => 15,
                'p' => 16,
                'q' => 17,
                'r' => 18,
                's' => 19,
                't' => 20,
                'u' => 21,
                'v' => 22,
                'w' => 23,
                'x' => 24,
                'y' => 25,
                'z' => 26,
                '_' => 27,
                _ => return Err(SymbolParsingError {}),
            };
            data *= 28;
            data += val;
        }
        Ok(Symbol { data })
    }
}

impl TryFrom<String> for Symbol {
    type Error = SymbolParsingError;

    fn try_from(value: String) -> core::result::Result<Self, Self::Error> {
        Symbol::try_from(value.as_str())
    }
}

impl TryFrom<&String> for Symbol {
    type Error = SymbolParsingError;

    fn try_from(value: &String) -> core::result::Result<Self, Self::Error> {
        Symbol::try_from(value.as_str())
    }
}

impl From<Symbol> for String {
    fn from(value: Symbol) -> Self {
        let mut n = value.data;
        let mut chars: Vec<char> = Vec::new();
        loop {
            let i = n % ALPHABET_LEN;
            n -= i;
            n /= ALPHABET_LEN;
            chars.push(ALPHABET[i as usize]);
            if n == 0 {
                break;
            }
        }
        chars.into_iter().rev().collect()
    }
}

impl From<&Symbol> for String {
    fn from(value: &Symbol) -> Self {
        (*value).into()
    }
}

impl Debug for Symbol {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result {
        f.debug_struct("Symbol")
            .field("data", &self.data)
            .field("symbol", &String::from(*self))
            .finish()
    }
}

impl Display for Symbol {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result {
        f.write_str(&self.to_string())
    }
}
